using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;


namespace Shaka.Godot.OnReady;

[Generator]
public class OnReadyGenerator : IIncrementalGenerator
{
    private const string Namespace = "Shaka.Godot.OnReady";
    public const string OnReadyAttribute = "OnReadyAttribute";
    private static string AttributeNameShort => OnReadyAttribute.Substring(0, OnReadyAttribute.Length - 9);

    private const string 
        AttributeSourceCode = $$"""
                                // <auto-generated/>
                                using System;

                                namespace {{Namespace}};

                                /// <summary>
                                /// Attribute that automatically defers initialization of a member until its called.
                                /// </summary>
                                [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property)]
                                public class {{OnReadyAttribute}} : Attribute
                                {
                                    /// <summary>
                                    /// Relative or absolute path in a scene tree like <see cref="Godot.NodePath"/>
                                    /// </summary>
                                    public string NodePath { get; }
                                
                                    /// <summary>
                                    /// Constructs a new OnReadyAttribute instance.
                                    /// </summary>
                                    /// <param name="nodePath">Relative or absolute path in a scene tree like <see cref="Godot.NodePath"/></param>
                                    public OnReadyAttribute(string nodePath)
                                    {
                                        NodePath = nodePath;
                                    }
                                }
                                """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Add the onready attribute to the compilation
        context.RegisterPostInitializationOutput(ctx => 
            ctx.AddSource($"{OnReadyAttribute}.g.cs", SourceText.From(AttributeSourceCode, Encoding.UTF8))
        );
        
        var provider = context.SyntaxProvider.CreateSyntaxProvider(
                predicate: static (s, _) => IsClassWithOnReadyMember(s),
                transform: static (ctx, _) => GetTarget(ctx));
        
        var classes = context.CompilationProvider.Combine(provider.Collect());
        
        context.RegisterSourceOutput(classes, (spc, source) => Execute(source.Item1, source.Item2, spc));
    }

    private static bool IsClassWithOnReadyMember(SyntaxNode syntaxNode)
    {
        return syntaxNode is ClassDeclarationSyntax classDecl &&
               classDecl.AnyMemberHasAttribute(AttributeNameShort, SyntaxKind.MethodDeclaration, SyntaxKind.PropertyDeclaration);
    }
    
    private static void Execute(Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classes, SourceProductionContext ctx)
    {
        
        var classSymbols = GetClassSymbols(compilation, classes);
        List<OnReadyClass> onReadyClasses = [];
        foreach (var typeSymbol in classSymbols)
        {
            var onReadyMembers = typeSymbol
                .GetMembers()
                .Where(m => OnReadyMember.Validate(typeSymbol, m, ctx))
                .Select(OnReadyMember.From)
                .ToList();
            
            if (onReadyMembers.Count > 0)
            {
                onReadyClasses.Add(new OnReadyClass(typeSymbol.ToDisplayString(), onReadyMembers));
            }
        }

        foreach (var onReadyClass in onReadyClasses)
        {
            ctx.AddSource($"{onReadyClass.FullName}.g.cs", SourceText.From(onReadyClass.ToSource(), Encoding.UTF8));
        }
    }

    private static IEnumerable<INamedTypeSymbol> GetClassSymbols(Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classDeclarations)
    {
        return classDeclarations.Select(c => GetCLassSymbol(compilation, c))
            .Where(symbol => symbol is not null)
            .Cast<INamedTypeSymbol>();
    }

    private static INamedTypeSymbol? GetCLassSymbol(Compilation compilation, ClassDeclarationSyntax classDeclaration)
    {
        var model = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
        return model.GetDeclaredSymbol(classDeclaration);
    }

    private static ClassDeclarationSyntax GetTarget(GeneratorSyntaxContext context) => (ClassDeclarationSyntax)context.Node;
}