using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Shaka.Godot.OnReady;

public interface ISourceText
{
    public string ToSource();
}

public partial record OnReadyClass(string FullName, List<OnReadyMember> Members) : ISourceText;

public abstract partial record OnReadyMember(string Name, string Type, string NodePath) : ISourceText;

public partial record OnReadyMethod(string Name, string Type, string NodePath) : OnReadyMember(Name, Type, NodePath);

public partial record OnReadyProperty(string Name, string Type, string NodePath) : OnReadyMember(Name, Type, NodePath);

partial record OnReadyClass
{
    public string ToSource()
    {
        var namespaceStatement = Namespace.Length > 0 ? $"namespace {Namespace};" : string.Empty;

        var onReadyClass = @$"// <auto-generated/>
using Godot;
{namespaceStatement}
partial class {Name}
{{
    {string.Join("\n\n", Members.Select(m => m.ToSource())).Indent(1)}
}}
";
        return onReadyClass;
    }

    public string Name
    {
        get
        {
            if (string.IsNullOrEmpty(field))
            {
                field = FullName.Split('.').Last();
            }

            return field;
        }
    } = string.Empty;

    public string Namespace
    {
        get
        {
            if (string.IsNullOrEmpty(field))
            {
                field = NamespaceFromFullName();
            }

            return field;
        }
    } = string.Empty;

    public string FullNameWithoutGlobal
    {
        get
        {
            if (string.IsNullOrEmpty(field))
            {
                field = FullName.Split(':', ':')[1];
            }

            return field;
        }
    } = string.Empty;

    private string NamespaceFromFullName()
    {
        var parts = FullName.Split('.');
        return string.Join(".", parts.Take(parts.Length - 1));
    }
}

partial record OnReadyMember
{
    public abstract string ToSource();

    public static OnReadyMember From(ISymbol symbol)
    {
        var attributeData = symbol.GetAttribute(OnReadyGenerator.OnReadyAttribute);

        return symbol switch
        {
            IPropertySymbol prop when prop.Type.IsNodeType() => From(prop, attributeData!),
            IMethodSymbol method when method.ReturnType.IsNodeType() => From(method, attributeData!),
            _ => throw new NotImplementedException($"Method of type {symbol.GetType()} is not supported.")
        };
    }

    private static OnReadyMember From(IPropertySymbol prop, AttributeData attributeData) =>
        new OnReadyProperty(prop.Name, prop.Type.FullNameGlobal(), attributeData.GetFirstStringValueOrEmpty());

    private static OnReadyMember From(IMethodSymbol method, AttributeData attributeData) =>
        new OnReadyMethod(method.Name, method.ReturnType.FullNameGlobal(), attributeData.GetFirstStringValueOrEmpty());

    public static bool Validate(INamedTypeSymbol classType, ISymbol symbol, SourceProductionContext ctx)
    {
        if (!symbol.HasAttribute(OnReadyGenerator.OnReadyAttribute)) return false;

        var validationInfo = OnReadyMemberValidationInfo.Create(symbol);
        var result = true;
        
        if (!classType.IsNodeType())
        {
            ctx.ReportDiagnostic(
                Diagnostic.Create(
                    Analyzers.ParentClassMustDeriveFromNode,
                    symbol.Locations.First()
                )
            );
            result = false;
        }
        
        if (!validationInfo.Type.IsNodeType())
        {
            ctx.ReportDiagnostic(
                Diagnostic.Create(
                    Analyzers.OnReadyMemberReturnMustDeriveFromNode,
                    symbol.Locations.First(),
                    symbol.Name
                )
            );
            result = false;
        }

        if (!validationInfo.IsPartial)
        {
            ctx.ReportDiagnostic(
                Diagnostic.Create(
                    Analyzers.OnReadyMemberMustBeEmptyPartial,
                    symbol.Locations.First(),
                    symbol.Name
                )
            );
            result = false;
        }
        
        if (!validationInfo.IsReadOnly)
        {
            ctx.ReportDiagnostic(
                Diagnostic.Create(
                    Analyzers.OnReadyPropertyIsNotReadOnly,
                    symbol.Locations.First(),
                    symbol.Name
                )
            );
            result = false;
        }

        if (validationInfo.IsStatic)
        {
            ctx.ReportDiagnostic(
                Diagnostic.Create(
                    Analyzers.OnReadyMemberCannotBeStatic,
                    symbol.Locations.First(),
                    symbol.Name
                )
            );
            result = false;
        }

        if (!classType.IsPartial())
        {
            ctx.ReportDiagnostic(
                Diagnostic.Create(
                    Analyzers.ParentClassMustBePartial,
                    symbol.Locations.First()
                )
            );
            result = false;
        }

        return result;
    }
}

partial record OnReadyMethod
{
    public override string ToSource()
    {
        string onReadyMember =
            @$"public partial {Type} {Name}()
{{
    return GetNode<{Type}>(""{NodePath}"");
}}";
        return onReadyMember;
    }
}

partial record OnReadyProperty
{
    public override string ToSource()
    {
        return @$"public partial {Type} {Name} => GetNode<{Type}>(""{NodePath}"");";
    }
}

internal record OnReadyMemberValidationInfo(ITypeSymbol Type, bool IsPartial, bool IsStatic, bool IsReadOnly)
{
    internal static OnReadyMemberValidationInfo Create(ISymbol symbol)
    {
        
        ITypeSymbol type;
        bool isPartial;
        bool isStatic = symbol.IsStatic;
        bool isReadOnly = true;
        switch (symbol)
        {
            case IPropertySymbol prop:
                type = prop.Type;
                isPartial = prop.IsPartialDefinition;
                isReadOnly = prop.IsReadOnly;
                break;
            case IMethodSymbol method:
                type = method.ReturnType;
                isPartial = method.IsPartialDefinition;
                break;
            default:
                throw new NotImplementedException($"Method of type {symbol.GetType()} is not supported.");
        }

        return new OnReadyMemberValidationInfo(type, isPartial, isStatic, isReadOnly);
    }
}