using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace Shaka.Godot.OnReady;

public interface ISourceText
{
    public string ToSource();
}

public partial record OnReadyClass(string FullName, List<OnReadyMember> Members) : ISourceText;

public abstract partial record OnReadyMember(string Name, Accessibility Accessibility, string Type, bool Nullable, string NodePath) : ISourceText;

public partial record OnReadyMethod(string Name, Accessibility Accessibility, string Type, bool Nullable, string NodePath) : OnReadyMember(Name, Accessibility, Type, Nullable, NodePath);

public partial record OnReadyProperty(string Name, Accessibility Accessibility, string Type, bool Nullable, string NodePath) : OnReadyMember(Name, Accessibility, Type, Nullable, NodePath);

partial record OnReadyClass
{
    public string ToSource()
    {
        var namespaceStatement = Namespace.Length > 0 ? $"namespace {Namespace};" : string.Empty;

        var onReadyClass = $$"""
                             // <auto-generated/>
                             using Godot;
                             {{namespaceStatement}}
                             #nullable enable
                             partial class {{Name}}
                             {
                                 {{string.Join("\n\n", Members.Select(m => m.ToSource())).Indent(1)}}
                             }
                             #nullable restore
                             """;
        return onReadyClass;
    }

    public string Name
    {
        get
        {
            if (string.IsNullOrEmpty(field))
            {
                field = FullName.Split('.').Last();
            }

            return field;
        }
    } = string.Empty;

    public string Namespace
    {
        get
        {
            if (string.IsNullOrEmpty(field))
            {
                field = NamespaceFromFullName();
            }

            return field;
        }
    } = string.Empty;

    public string FullNameWithoutGlobal
    {
        get
        {
            if (string.IsNullOrEmpty(field))
            {
                field = FullName.Split(':', ':')[1];
            }

            return field;
        }
    } = string.Empty;

    private string NamespaceFromFullName()
    {
        var parts = FullName.Split('.');
        return string.Join(".", parts.Take(parts.Length - 1));
    }
}

partial record OnReadyMember
{
    protected string AccessModifier => SyntaxFacts.GetText(Accessibility);
    protected string PrivateName
    {
        get
        {
            if (string.IsNullOrWhiteSpace(field))
            {
                field = Name.ToUnderScoreFirstLower();
            }

            return field;
        }
    } = string.Empty;
    protected string PrivateMember => $$"""
                                        private {{Type}}? {{PrivateName}}
                                        {
                                            [Obsolete("This is the backing field for the autogenerated OnReady member '{{Name}}'. Please use '{{Name}}' to access the value.")]
                                            get; 
                                            set;
                                        }
                                        """;
    protected string NodeStatement =>
            Nullable 
            ? $"""GetNodeOrNull<{Type}>("{NodePath}")""" 
            : $"""GetNode<{Type}>("{NodePath}")""";
    protected string NullableModifier => Nullable ? "?" : "";

    public abstract string ToSource();

    public static OnReadyMember From(ISymbol symbol)
    {
        var attributeData = symbol.GetAttribute(OnReadyGenerator.OnReadyAttribute);

        return symbol switch
        {
            IPropertySymbol prop when prop.Type.IsNodeType() => From(prop, attributeData),
            IMethodSymbol method when method.ReturnType.IsNodeType() => From(method, attributeData),
            _ => throw new NotImplementedException($"Method of type {symbol.GetType()} is not supported.")
        };
    }

    private static OnReadyMember From(IPropertySymbol prop, AttributeData attributeData) =>
        new OnReadyProperty(
            prop.Name, 
            prop.DeclaredAccessibility, 
            prop.Type.FullNameGlobal(), 
            prop.Type.IsNullable(), 
            attributeData.GetFirstStringValueOrEmpty()
        );

    private static OnReadyMember From(IMethodSymbol method, AttributeData attributeData) =>
        new OnReadyMethod(
            method.Name, 
            method.DeclaredAccessibility, 
            method.ReturnType.FullNameGlobal(), 
            method.ReturnType.IsNullable(), 
            attributeData.GetFirstStringValueOrEmpty()
        );

    public static bool Validate(INamedTypeSymbol classType, ISymbol symbol, SourceProductionContext ctx)
    {
        if (!symbol.HasAttribute(OnReadyGenerator.OnReadyAttribute)) return false;

        var validationInfo = OnReadyMemberValidationInfo.Create(symbol);
        var result = true;
        
        if (!classType.IsNodeType())
        {
            ctx.ReportDiagnostic(
                Diagnostic.Create(
                    Analyzers.ParentClassMustDeriveFromNode,
                    symbol.Locations.First()
                )
            );
            result = false;
        }
        
        if (!validationInfo.Type.IsNodeType())
        {
            ctx.ReportDiagnostic(
                Diagnostic.Create(
                    Analyzers.OnReadyMemberReturnMustDeriveFromNode,
                    symbol.Locations.First(),
                    symbol.Name
                )
            );
            result = false;
        }

        if (!validationInfo.IsPartial)
        {
            ctx.ReportDiagnostic(
                Diagnostic.Create(
                    Analyzers.OnReadyMemberMustBeEmptyPartial,
                    symbol.Locations.First(),
                    symbol.Name
                )
            );
            result = false;
        }
        
        if (!validationInfo.IsReadOnly)
        {
            ctx.ReportDiagnostic(
                Diagnostic.Create(
                    Analyzers.OnReadyPropertyIsNotReadOnly,
                    symbol.Locations.First(),
                    symbol.Name
                )
            );
            result = false;
        }

        if (validationInfo.IsStatic)
        {
            ctx.ReportDiagnostic(
                Diagnostic.Create(
                    Analyzers.OnReadyMemberCannotBeStatic,
                    symbol.Locations.First(),
                    symbol.Name
                )
            );
            result = false;
        }

        if (!classType.IsPartial())
        {
            ctx.ReportDiagnostic(
                Diagnostic.Create(
                    Analyzers.ParentClassMustBePartial,
                    symbol.Locations.First()
                )
            );
            result = false;
        }

        return result;
    }
}

partial record OnReadyMethod
{
    public override string ToSource()
    {
        var onReadyMember =
            $$"""
              {{PrivateMember}}
              {{AccessModifier}} partial {{Type}}{{NullableModifier}} {{Name}}()
              {
                  return {{PrivateName}} ??= {{NodeStatement}};
              }
              """;
        return onReadyMember;
    }
}

partial record OnReadyProperty
{
    public override string ToSource()
    {
        return $"""
                {PrivateMember}
                {AccessModifier} partial {Type} {Name} => {PrivateName} ??= {NodeStatement};
                """;
    }
}

internal record OnReadyMemberValidationInfo(ITypeSymbol Type, bool IsPartial, bool IsStatic, bool IsReadOnly)
{
    internal static OnReadyMemberValidationInfo Create(ISymbol symbol)
    {
        
        ITypeSymbol type;
        bool isPartial;
        bool isStatic = symbol.IsStatic;
        bool isReadOnly = true;
        switch (symbol)
        {
            case IPropertySymbol prop:
                type = prop.Type;
                isPartial = prop.IsPartialDefinition;
                isReadOnly = prop.IsReadOnly;
                break;
            case IMethodSymbol method:
                type = method.ReturnType;
                isPartial = method.IsPartialDefinition;
                break;
            default:
                throw new NotImplementedException($"Method of type {symbol.GetType()} is not supported.");
        }

        return new OnReadyMemberValidationInfo(type, isPartial, isStatic, isReadOnly);
    }
}