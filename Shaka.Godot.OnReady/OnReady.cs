using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;

namespace Shaka.Godot.OnReady;

public interface ISourceText
{
    public string ToSource();
}

public partial record OnReadyClass(string FullName, List<OnReadyMember> Members) : ISourceText;

public abstract partial record OnReadyMember(string Name, string Type, string NodePath) : ISourceText;

public partial record OnReadyMethod(string Name, string Type, string NodePath) : OnReadyMember(Name, Type, NodePath);

public partial record OnReadyProperty(string Name, string Type, string NodePath) : OnReadyMember(Name, Type, NodePath);

partial record OnReadyClass
{
    public string ToSource()
    {
        var namespaceStatement = Namespace.Length > 0 ? $"namespace {Namespace};" : string.Empty;

        var onReadyClass = @$"// <auto-generated/>
using Godot;
{namespaceStatement}
partial class {Name}
{{
    {string.Join("\n\n", Members.Select(m => m.ToSource())).Indent(1)}
}}
";
        return onReadyClass;
    }

    public string Name
    {
        get
        {
            if (string.IsNullOrEmpty(field))
            {
                field = FullName.Split('.').Last();
            }

            return field;
        }
    } = string.Empty;

    public string Namespace
    {
        get
        {
            if (string.IsNullOrEmpty(field))
            {
                field = NamespaceFromFullName();
            }

            return field;
        }
    } = string.Empty;

    public string FullNameWithoutGlobal
    {
        get
        {
            if (string.IsNullOrEmpty(field))
            {
                field = FullName.Split(':', ':')[1];
            }

            return field;
        }
    } = string.Empty;

    private string NamespaceFromFullName()
    {
        var parts = FullName.Split('.');
        return string.Join(".", parts.Take(parts.Length - 1));
    }
}

partial record OnReadyMember
{
    public abstract string ToSource();

    public static OnReadyMember From(ISymbol symbol)
    {
        var attributeData = symbol.GetAttribute(OnReadyGenerator.OnReadyAttribute);

        return symbol switch
        {
            IPropertySymbol prop when prop.Type.IsNodeType() => From(prop, attributeData!),
            IMethodSymbol method when method.ReturnType.IsNodeType() => From(method, attributeData!),
            _ => throw new NotImplementedException($"Method of type {symbol.GetType()} is not supported.")
        };
    }

    public static OnReadyMember From(IPropertySymbol prop, AttributeData attributeData) =>
        new OnReadyProperty(prop.Name, prop.Type.FullNameGlobal(), attributeData.GetFirstStringValueOrEmpty());

    public static OnReadyMember From(IMethodSymbol method, AttributeData attributeData) =>
        new OnReadyMethod(method.Name, method.ReturnType.FullNameGlobal(), attributeData.GetFirstStringValueOrEmpty());

    public static bool Validate(ISymbol symbol, SourceProductionContext ctx)
    {
        if (!symbol.HasAttribute(OnReadyGenerator.OnReadyAttribute)) return false;

        var (type, isPartial, isStatic) = ValidationInfo(symbol);
        var result = true;
        if (!type.IsNodeType())
        {
            ctx.ReportDiagnostic(
                Diagnostic.Create(
                    Analyzers.OnReadyMemberReturnMustDeriveFromNode,
                    symbol.Locations.First(),
                    symbol.Name
                )
            );
            result = false;
        }

        if (!isPartial)
        {
            ctx.ReportDiagnostic(
                Diagnostic.Create(
                    Analyzers.OnReadyMemberMustBeEmptyPartial,
                    symbol.Locations.First(),
                    symbol.Name
                )
            );
            result = false;
        }

        if (isStatic)
        {
            ctx.ReportDiagnostic(
                Diagnostic.Create(
                    Analyzers.OnReadyMemberCannotBeStatic,
                    symbol.Locations.First(),
                    symbol.Name
                )
            );
            result = false;
        }

        return result;
    }

    private static (ITypeSymbol type, bool isPartial, bool isStatic) ValidationInfo(ISymbol symbol)
    {
        ITypeSymbol type;
        bool isPartial;
        bool isStatic = symbol.IsStatic;
        switch (symbol)
        {
            case IPropertySymbol prop:
                type = prop.Type;
                isPartial = prop.IsPartialDefinition;
                break;
            case IMethodSymbol method:
                type = method.ReturnType;
                isPartial = method.IsPartialDefinition;
                break;
            default:
                throw new NotImplementedException($"Method of type {symbol.GetType()} is not supported.");
        }

        return (type, isPartial, isStatic);
    }
}

partial record OnReadyMethod
{
    public override string ToSource()
    {
        string onReadyMember =
            @$"public partial {Type} {Name}()
{{
    return GetNode<{Type}>(""{NodePath}"");
}}";
        return onReadyMember;
    }
}

partial record OnReadyProperty
{
    public override string ToSource()
    {
        return @$"public partial {Type} {Name} => GetNode<{Type}>(""{NodePath}"");";
    }
}